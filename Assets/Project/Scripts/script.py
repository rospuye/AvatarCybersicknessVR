#
# ------ INSTRUCTIONS ------
# In order for everything to work correctly, the folder structure should be:
#
# ├── script.py
# ├── APP_DATA/
# │   ├── id1.csv
# │   ├── id2.csv
# │   └── (...)
# └── export.xml
#
# where script.py is this script, APP_DATA contains all the CSV files generated by the
# Unity application and export.xml is the XML file exported from the Apple Watch.
#
# ------ RESULTS ------
# Inside its own folder, this script will create the following structure:
#
# └── BIOMETRIC_RESULTS/
#     ├── id1/
#     │   ├── heartbeat_seated_avatar.csv
#     │   ├── heartbeat_seated_noavatar.csv
#     │   ├── heartbeat_walking_avatar.csv
#     │   └── heartbeat_walking_noavatar.csv
#     ├── id2/
#     │   └── (...)
#     └── (...)
#
# where the IDs correspond to those naming the APP_DATA CSV files and where, for each user
# and each scenario, it'll save heartbeat information, also in a CSV file.
#

import xml.etree.ElementTree as ET
from datetime import datetime,timezone
import re
import os
import csv
import glob

def extract_scenario_information(file_path):
    with open(file_path, 'r') as file:
        lines = file.readlines()
    
    scenarios = {}
    current_scenario = None
    for line in lines:
        line = line.strip()
        if line.startswith("SCENARIO_"):
            current_scenario = line
            scenarios[current_scenario] = []
        elif line.startswith("TimerStopped"):
            continue
        elif line.startswith("Timestamp,MovementDeltaX,MovementDeltaY,MovementDeltaZ,TotalMovementDelta"):
            continue
        elif current_scenario:
            scenarios[current_scenario].append(line)
    
    return scenarios

def get_start_and_end_timestamps(scenario_lines):
    first_line = scenario_lines[0]
    last_line = scenario_lines[-1]

    # string timestamps
    timestamp_start_str = first_line.split(",")[0]
    timestamp_end_str = last_line.split(",")[0]

    # turn them into datetime objects
    timestamp_start = datetime.strptime(timestamp_start_str, "%m/%d/%Y %I:%M:%S %p")
    timestamp_end = datetime.strptime(timestamp_end_str, "%m/%d/%Y %I:%M:%S %p")

    # add timezone to make it the same as the Apple Watch format
    timestamp_start = timestamp_start.replace(tzinfo=timezone.utc)
    timestamp_end = timestamp_end.replace(tzinfo=timezone.utc)

    return timestamp_start, timestamp_end

def format_iso_string(iso_string):
    """
    Adjusts the Apple Watch's timezone offset format in a given datetime string to ensure
    compatibility with the datetime library for proper parsing and interpretation.
    """
    pattern = r"([+-]\d{2})(\d{2})$"
    formatted_string = re.sub(pattern, r"\1:\2", iso_string.strip())
    return formatted_string

def remove_timezone_offset(iso_string):
    """
    Removes timezone offset from an ISO 8601 datetime string.
    """
    dt = datetime.fromisoformat(iso_string)
    return dt.replace(tzinfo=None).isoformat()

def find_relevant_records(xml_file, start, end, type):
    """
    Finds all Record tags whose 'startDate' and 'endDate' attributes are included within
    the timespan between 'start' and 'end', and whose 'type' attribute is the same as
    the input 'type'.
    """
    tree = ET.parse(xml_file)
    root = tree.getroot()
    
    records = []
    
    for record in root.findall('.//Record'):
        recordType = record.get('type')
        if (recordType != type):
            continue

        start_date = format_iso_string(record.get('startDate'))
        end_date = format_iso_string(record.get('endDate'))

        if start_date and end_date:
            record_start_dt = datetime.fromisoformat(start_date)
            record_end_dt = datetime.fromisoformat(end_date)
            
            if start <= record_start_dt and end >= record_end_dt:
                records.append(record)

    return records

if __name__ == "__main__":

    folder_path = "APP_DATA"
    xml_file = "export.xml"
    csv_files = glob.glob(os.path.join(folder_path, "*.csv"))

    for application_file in csv_files:

        id = os.path.splitext(os.path.basename(application_file))[0]
        application_data = extract_scenario_information(application_file)

        for scenario, lines in application_data.items():
            shortened_scenario = scenario.replace("SCENARIO_", "", 1)
            start, end = get_start_and_end_timestamps(lines)

            heartBeatType = "HKQuantityTypeIdentifierHeartRate"
            energyBurnedType = "HKQuantityTypeIdentifierActiveEnergyBurned"

            heartbeat_records = find_relevant_records(xml_file, start, end, heartBeatType)
            heartbeat_data = [[r.get('startDate'), r.get('endDate'), r.get('value')] for r in heartbeat_records]

            # energy_records = find_relevant_records(xml_file, start, end, energyBurnedType)
            # energy_data = [[r.get('startDate'), r.get('endDate'), r.get('value')] for r in energy_records]

            folder_name = f"BIOMETRIC_RESULTS/{id}"
            os.makedirs(folder_name, exist_ok=True)

            with open(f'{folder_name}/heartbeat_{shortened_scenario}.csv', mode='w', newline='') as file:
                writer = csv.writer(file)
                writer.writerows(heartbeat_data)

            # with open(f'{folder_name}/energy.csv', mode='w', newline='') as file:
            #     writer = csv.writer(file)
            #     writer.writerows(energy_data)